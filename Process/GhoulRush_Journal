# Week 7: Iterative Prototype 1
> Journal about the first stage of your prototyping process. What was your idea? What specific questions where you trying to answer (goals)? Was it a look/feel, role, implementation prototype?What fidelity levels are you dealing with? What did you learn and what are the next steps?

## Idea
Our primary concept is a **defend-the-castle** style game where the player must protect a magical crystal (or orb, etc) from waves of incoming monsters. The core mechanics revolve around spellcasting: the player uses projectiles or spells to repel enemies that spawn at increasing rates. This forms the foundation of our game, and we plan to layer additional features—like varying environments, elemental power-ups, and possibly an inventory system—after we establish the basic combat loop.

### Design Values
1.  **Immersion in a Magical World**: We want players to feel truly embedded in a fantasy realm, experiencing the thrill of spellcasting and defending a sacred artifact.
2.  **Progression & Challenge**: As waves increase in difficulty, the sense of progression is key, offering a rewarding loop for players who successfully upgrade or learn new spells.
3.  **Scalability**: Start with a simple but solid core (castle defense), then scale up with new elements (inventory, environment interactions, elemental powers) if time permits.
4.  **Player Agency**: The player should have multiple spellcasting choices and strategic options (e.g., positioning, resource management) to keep the gameplay engaging and varied.

### Three favourite ideas
1.   **Mini Open-World with Combat & Magic**  
    Inspired by _Zelda: TOTK_ and _Elden Ring_, a small but explorable environment where players can gather resources for spells, interact with NPCs, and fight roaming monsters.
    
2.   **Horde Defense with Elemental Interactions**  
    Waves of enemies approach while the player uses elemental spells (fire, ice, lightning, etc.) that can combine for special effects (e.g., oil + fire = increased burn damage).
    
3.   **Puzzle-Integrated Spellcasting**  
    A puzzle layer in which spell combinations unlock doors or reveal hidden paths—possibly using illusions or invisibility to navigate stealth segments.
    
We ultimately chose to focus on the **horde defense** aspect first, as it offers a clear core challenge and is easier to implement in our initial prototype.

## Goals

First, we aim to get the barebones foundation of our defend-the-castle game working. These steps will let us test the core loop: the player casts spells at waves of monsters trying to destroy the orb.
### Weekly Goals
- [ ]    **Create a Monster GameObject** (basic model/placeholder)
- [ ] **Create a Crystal/Orb GameObject** (the target to defend)
- [ ] **Implement Basic Projectile/Spellcasting**
	- Simple projectile script
	- Collision detection with monsters (could potentially use my previous collision detection script)
- [ ] **Set Up a Simple Wave Spawner** (enemy waves) (could use my spawner script)
	- Very basic AI to move towards the orb
- [ ] **Implement Health & Damage**
	- Monster health/dying on 0 HP
	- Orb health (game over if destroyed)
	- Player health
- [ ]    **Basic UI feedback** (player health, crystal health, score).

Our immediate goal is to validate the core gameplay loop—does defending an object with spell-based combat feel satisfying, challenging, and fun? By testing early, we can confirm whether our combat mechanics are engaging enough to expand upon.

##  Questions We’re Trying to Answer
1.  Can we implement smooth spellcasting mechanics with a basic projectile system in Unity?
2.  Is the pacing of enemy waves balanced for a “defend-the-orb” style challenge to maintain player engagement?
3.  How feasible is it to add additional features (inventory, elemental combos, etc.) later without breaking the core loop? 

### Was it a look/feel, role, or implementation prototype?
This prototype primarily focuses on **implementation**. We are building scripts for monster AI, projectile casting, and object defense to see if our gameplay mechanics work under real conditions. While we do care about some basic aesthetic consistency (a fantasy look/feel), the priority is functional testing over polished visuals.

### Fidelity Levels
**Low- to Mid-Fidelity**: We’re using placeholder 3D assets or basic shapes, as well as simple UI elements for scoring and health. This allows us to iterate on gameplay without getting bogged down by final art or detailed environment design.

## Next Steps
- [ ] **Integrate Scoring** using existing scoring system
- [ ] **Implement Basic Spellcasting**:
    -   Use a projectile system in Unity.
    -   Ensure it feels responsive (speed, damage, cooldown).
- [ ] **Create Enemy Waves**:
    -   Set up a spawner that gradually increases wave difficulty.
    -   Basic AI: move towards the crystal/orb and attempt to damage it.
    - Adjust speed, spawn rate, difficulty)
- [ ] **Protect the Crystal**:
    -   Implement a health system for the orb (and possibly the player).
    -   Show basic feedback when the crystal is hit.
- [ ] **Set Up a Simple Scoring System** _(already made in Unity but needs integration)_
    -   Points awarded per monster killed.
    -   Possibly track wave count or “time survived.”
- [ ] **Refine Enemy AI and Balancing**
    -   Tweak spawn rates, enemy health, and damage for a more engaging pace.
    -   Consider different enemy types if time allows (faster but weaker vs. slower but stronger).
- [ ] **Enhance Spellcasting System**
		-   Implement cooldowns and a basic mana resource.
	    -   Experiment with elemental spells (fire, ice, lightning) to test synergy.
- [ ] **Improve UI/UX**
    -   Display player health, orb health, wave counters, and scoring in a clean layout to track progression
    -   Add simple menus or pause screens as needed.
- [ ] **Expand to Elemental Power-Ups**  
    -   Introduce special items or pickups that alter spell damage or add new spell effects.
 
**Ideas for Broader Features (If time permits):**

-   **Shop** with points and upgrades, and interface
	- [inspiration game](https://www.crazygames.com/game/defend-your-castle)
-   **Explore Elemental Power-Ups** prototype collecting items that grant different spell attributes or buffs.
- **Elemental Power-Ups**   Introduce special GameObjects (e.g.: fire/ice mushrooms/peppers/crystals) that alter spell damage or add new spell effects, and potentially add interactions between them
		- could be stored in an inventory system, or the player could automatically wield special new mana (and then maybe use left and right arrow keys to switch between spell type)
- **Mini Open World Features**  shop, puzzle area(s), treasure chests, buildings, NPC's
	-   **Puzzle Integration** puzzle areas


# Week 8: Iterative Prototype 2: Adding Enemy AI & Health Mechanics

![AttackHP](https://github.com/xaynia/CART-315/blob/main/Process/Images/FinalProject/Attack2.gif)

> Journal about the first stage of your prototyping process. What was your idea? What specific questions were you trying to answer (goals)? Was it a look/feel, role, or implementation prototype? What fidelity levels are you dealing with? What did you learn and what are the next steps?

### Last Weeks Accomplished Goals
- [x]    **Create a Monster GameObject** (basic model/placeholder)
- [x] **Create a Crystal/Orb GameObject** (the target to defend)
- [ ] **Implement Basic Projectile/Spellcasting**
	- Simple projectile script
	- Collision detection with monsters (could potentially use my previous collision detection script)
- [ ] **Set Up a Simple Wave Spawner** (enemy waves) (could use my spawner script)
	- Very basic AI to move towards the orb
- [x] **Implement Health & Damage**
	- Monster health/dying on 0 HP
	- Orb health (game over if destroyed)
	- Player health
- [x]    **Basic UI feedback** (player health, crystal health, score).

## Idea

Building on the concept of a **defend-the-object, hoarde** style game with magic (spellcasting), this week I focused on implementing the fundamental systems behind **enemy movement**, **enemy attacks**, and an **HP/Health bar** system. The goal remains to create a horde-defense scenario where enemies spawn, move toward a critical target (like a magical crystal or orb), and attempt to damage it, while the player defends.

I introduced Enemy AI scripts that let enemies move toward the Target, attack if in range, and manage their own health. I also added a universal Health script that can be attached to the Player, the Target, and any Enemy. Also, I implemented a Health Bar UI element that appears when attacked, giving immediate visual feedback on damage.

1.  **Enemy Movement & Attack**
    -   The enemy moves toward a specified `Target` transform and attacks when within `attackRange`.
    -   A cooldown prevents it from spamming the attack every frame, preserving balance and clarity.
2.  **Health Script**
    -   Any character/object can have `maxHealth`, take damage via `TakeDamage(float)`, and handle death with a simple `Die()` method.
    -   An event-based approach (`OnHealthChanged`) allows the **Health Bar** to update only when damage actually occurs.
3.  **Health Bar UI**
    -   A World Space canvas and a fill `Image` let me display health visually above each entity.
    -   It’s now trivial to see if the Target or an Enemy is near death, or if the Player is about to be overrun.

### Design Values

-   **Clarity of Core Mechanics**: Ensure that the basic loop of “enemy spawns → enemy chases target → target/enemy takes damage” is solid.
-   **Simplicity and Extensibility**: Keep the scripts modular (Enemy script, Health script, HealthBar script) so they can be easily extended for multiple enemy types, player attacks, etc.
-   **Minimal**: working without game assets to get the core mechanics down before adding aesthetic features
- **Immediate Visual Feedback**: Add a minimal but clear UI component (the health bar) to show damage and health changes, to quickly grasp what’s happening when testing

## Goals
My goal was to start implementing a core foundation (enemy AI movement and attack, health logic [i.e. damage & death],) to setup a basic defend-the-object prototype. This lays the groundwork for future expansions— enemy hordes, adding player spellcasting, and so on.

## Questions to Answer

-  **Does a single “Health” component work well for multiple objects?**
    -   Yes—things remain consistent, and debugging is simpler.
-  **Is the movement & attack AI robust enough for horde-style gameplay?**
    -   For a basic prototype, yes. I can build on it with pathfinding or advanced behaviors later.


### Was it a look/feel, role, or implementation prototype?

**Implementation Prototype**: The focus was on functional scripts (Enemy logic, HP system, UI feedback). The look remains placeholder-like, with minimal art (without assets) to validate the underlying mechanics, to build a foundation to expand upon later. Even so, the look/feel aspect of having a floating health bar contributes to clarity in the user experience.

### Fidelity Levels

**Low to Mid-Fidelity**: Using simple capsule placeholders for enemies, a minimal cube target object, and a simple green/red health bar. There’s no finalized art or animation—just enough mimimal visuals to verify functionality.

## Accomplishments
### Created an Enemy Script (Movement & Attack) (`Enemy.cs`):
   - **Movement**: Moves the enemy toward a designated `Target` transform using a `moveSpeed`.
   - ![Enemy-player.gif](https://github.com/xaynia/CART-315/blob/main/Process/Images/FinalProject/Enemy-player.gif)
   - **Attack Logic**:
        -   Defines an `attackRange` to decide how close the enemy must be to attack.
        -   Uses `attackDamage` to define how much damage is applied.
        -   Includes an `attackCooldown` to avoid attacking every single frame.
        -   ![Enemy Settings](https://github.com/xaynia/CART-315/blob/main/Process/Images/FinalProject/Enemy-script2.png)
- **Health System**: The enemy (as well as the player and target) can have the same `Health` script attached, allowing them to take damage and potentially be destroyed at 0 HP.

### Implemented a Universal Health Script (`Health.cs`):
   - Stores `maxHealth` and `currentHealth`.
   -  ![Health Settings](https://github.com/xaynia/CART-315/blob/main/Process/Images/FinalProject/Health-script.png)
   - Allows you to customize unique max health for any object (i.e., player, object, target) you put it on
    -  Provides a `TakeDamage(float amount)` method for reducing HP and checking for death.
    -  Notifies health bar via event (`OnHealthChanged`) when health changes
    - handle death with a simple `Die()` method.

### Added a Universal Health Bar UI (`HealthBar.cs)`:

   -   Created health bar UI using a World Space Canvas with a child Image serving as the fill for the health bar to display health visually above any objects head
   -   Ensures the bar only appears and depletes when the character is damaged.
   -   Positioned the health bar above each entity’s head for clarity
![Healthbar.gif](https://github.com/xaynia/CART-315/blob/main/Process/Images/FinalProject/Healthbar.gif)


## What I Learned

1.  **Reusability is Key**: Having one Health and HealthBar script for all objects saves a lot of work and ensures consistent damage/HP behavior. 
2.  **Feedback is Crucial**: Seeing an on-screen health bar clarifies the state of battle—makes it easier to test AI logic or balance.
3.  **Minimalism > Details to Start**: The simple approach to AI (direct movement to Target, no pathfinding) meets the immediate needs but might need upgrading 

## Next Steps (Goals)

- [ ]   **Magic/Projectile Player Attack Mechanism**: Add projectile magic for the player to damage enemies 
	- calling `TakeDamage` on hit)
- [ ]   **Integrate the Spawner** so multiple enemies (hordes) appear over time. 	
- [ ]   **Confiagure Horde Code**: Test how the current movement and attack logic scales with many enemies.
	- Tweak spawn rates, speeds, and wave size to test the core loop.
- [ ]   **Allow Enemies to Attack the Player** (not just the target), so the player must actively defend themselves.
- [ ]   **Polish & Balancing**: Tweak HP, damage values, and wave pacing to ensure the game is both challenging and fair.

### Question to answer: Once hoardes are set up with the spawner, will players remain engaged?

>**Longer-Term Ideas** (If time allows):
>- **Hoarde levels**: After integrating the spawner, add variation (levels, increasing difficulty) in enemy hoardes
>-   **Spell Variation** for the player: implement multiple spell types (fire, ice, chain lightning, etc.).
>-   **UI Enhancements**: More sophisticated health bars, possibly with floating damage text or icons.
>- **Shop**
>-  **Add “Death” Feedback**: Animations, sound effects, or particle effects for both enemies and the Target when they die.

## Links:
- [Link to Project](https://github.com/xaynia/CART-315/tree/main/Projects/Final)
- [Link to Project Media](https://github.com/xaynia/CART-315/tree/main/Process/Images/FinalProject)

# Week 9: Iterative Prototype 3: Added Game Over UI, Assets, Level Design

![TestingAssets](https://github.com/xaynia/CART-315/blob/main/Process/Images/FinalProject/TestingAssets2.png)

### Accomplished Goals

 - [x] Added Game Over UI (as a new scene)
 - [x] Downloaded Assets
 - [x] Started Level Design
 - [x] Added health bar to enemies

## Idea
With the core loop in mind, we are adding the most important features. The idea is during the wave you attack the horde while picking up objects in the scene and collecting them in your inventory. Then after the wave you can use the items you collected at the crafting area for a spell/weapon upgrade(s). Then repeat.

### Core Loop

 - **Level 1:**
	 - Horde
		 - Waves coming to player (waves progressively getting 
	 - 	 Gather items in the level
 - **Craft**
	 - Where you can use the items you collected to upgrade your weapon (e.g.: use red mushrooms you collected to unlock flamethrower)
 - **Level 2...** (repeat)

This is a look/feel and implementation prototype. It is a look/feel prototype as I am testing assets. I am also implementing UI and designing a game level with the assets.

#### Fidelity Levels:
It's a low-medium fidelity levels, adding assets from the Unity asset store and adding UI with TextMeshPro.

## Accomplishments

### Added Game Over UI 

![TestingAssets](https://github.com/xaynia/CART-315/blob/main/Process/Images/FinalProject/TestingAssets2.png)

First I made as a scene, using TextMeshPro again. The game over UI is called when the core aka target dies, causing the scene manager to load the game over scene, which pops up "Game Over" text, and a "Try Again" button, which brings the user back to the level when pressed.

In the game over scene: I created a UI canvas GameObject (with script), with a text child "Game Over", and a button child which on click () uses the parent script to run GameOverMenu OnTryAgainButtonPressed (). The button child has a text child for the "Try Again" text.

The script uses `usingUnityEngine.SceneManagement;` to call the new scene with `SceneManager.LoadScene()`

And using the health script, when the core (aka target) dies it calls a cursor (to click the try again button), followed by SceneManager to load the game over scene
`SceneManager.LoadScene("Scenes/Game Scene/GameOverScene");`

This is the basic logic for the UI, and the idea is to add more to it later (i.e.: high score, save, etc)

![GameOver](https://github.com/xaynia/CART-315/blob/main/Process/Images/FinalProject/GameOver2.gif)

### Downloaded Assets
I downloaded a bunch of assets to start designing and customizing the level.

**Questions**:

 - What is the difference between Built-in vs. URP (Universal Render Pipeline) vs. HDRP assets. 
 - When assets load in hot pink: are they incompatible? can they be converted?
 -  What is the asset manager useful for? how do you set it up?


### Started Game Level/Scene Design

#### Adding assets:
I'm using the assets to design the level for the game. I've made a scene to experiment with them. 

## What I Learned

To add a game over scene, I had to add a camera and event system for it to work properly. The camera had to be added to avoid a "no camera" popup over the UI when testing it. And the EventSystem is added to detect mouseclicks. Also I added all the scenes.

To use the scene manager to swap scenes, the scenes must be added to to the build profile (so the scene manager can load it). I used this for my game over UI.

## Next Steps (Goals)

 - [ ] Find red asset for collectable GameObject to craft flamethrower (red plants/mushrooms/gems etc)
 - [ ] Finish level/scene
	 - [ ] Add red collectable assets
 - [ ] Update Core/target health to enemy health bar
 - [ ] Add Wave Spawner to Spawner script: 
 
**UI:**
 
 - [ ] Add save system
 - [ ] Add high score
 - [ ] Configure score UI working (so it updates with enemies killed)

**Core/target:**
 
 - [ ] Swap health bar (swap out Health.cs with enemy health bar)

**Player:**
 - [ ] Add health (so enemies can damage the player)
	 - [ ] Add first person health bar

**Enemies:**
 - [ ] Add damage player feature (they currently follow the player but do no damage)
 - [ ] Add attack and damage core 

>**Longer-Term Ideas** (If time allows):
>- **Add bomb characters**: Add bomb character ([asset store](https://assetstore.unity.com/packages/3d/characters/3d-monster-bomb-145319)) to the level the player can explode to strategically do more damage
>- **Add sounds**: music, death sound effects, spell sound effects, etc...
>- **Add more crafting objects for different upgrades**: 
>- **Add more unique levels**

## Links:
- [Link to Shared Project](https://github.com/Noe235/CART315FinalProject)
- [Link to Project Media](link)

# Week 10: Iterative Prototype 4: 

![LevelProgress](https://github.com/xaynia/CART-315/blob/main/Process/Images/FinalProject/LevelScene.png)

> Journal about the first stage of your prototyping process. What was your idea? What specific questions were you trying to answer (goals)? Was it a look/feel, role, or implementation prototype? What fidelity levels are you dealing with? What did you learn and what are the next steps?

### Last Weeks Accomplished Goals

 - [x] Find red asset for collectable GameObject to craft flamethrower (red plants/mushrooms/gems etc)
 - [x] Finish level/scene 
	 - [x] Add red collectable assets
 - [x] Update Core/target health to enemy health bar (swap out Health.cs for enemy health bar)
 - [x] Update Horde script to attack core

## Idea

#### Finish the Core Loop Foundation
**Objective:**
 Ensure that the player, enemies, and core interact as intended—everyone can receive damage, and enemies can target either the core or the player.
- Update scripts so the player, enemies, and core have health, and take damage.
- Add horde waves

**Design:**
- **Level Design:** Continue creating an aesthetic game level/environment with assets to support the horde waves.
	- Add assets to core gameplay placeholders
		- Red mushroom assets to collect in inventory to craft into flamethrower
		- Crafting table asset
- **UI**: Continue working on UI
	- Add to game over screen:
		- Integrate: score, save system, save system

### Design Values

#### Core Gameplay
- **Complete the foundational core loop:** 
	- Emphasize a specific satisfying core loop of collecting resources, crafting weapons, and defending the core against waves of enemies. 
		- Resource Collection & Crafting: 
			- Players gather resources (e.g., red mushrooms) during waves, which they will eventually use to upgrade weapons or spells.
		- Player, enemy, core interaction:
			- Enemies attack either to player or core
		- Wave defense: The player and the core must survive against progressively harder waves. 
		- UI
	
- **Level Design**:
	- Start working on a low poly game scene, which can be expanded upon later (i.e., more levels and/or more detail).
		- Add assets
			- Core, player, enemies
			- Crafting table
			- Environment/landscape

## Questions to Answer


### Was it a look/feel, role, or implementation prototype?
**Implementation prototype:** for implementing health script logic (changing Health.cs to us EnemyHealth.cs logic), and updated FollowingEnemy.cs to attack either core or player.

**Look/Feel**: from integrating the assets to start solid placeholders for the level,

### Fidelity Levels
**Mid-high fidelity design:** Although not fully polished, by creating a solid foundation for our level by figuring out assets and getting designing the level, I feel confident about our design going forward. 

**Mid implementation**: replacing scripts, setting up logic for wave spawning, health bars, UI. I'm getting better at this, but  always takes quite a bit of time, especially understanding script logic you haven't written. Overall, it's working but not totally optimized or polished and still has a ways to go (but it's getting there).

**Mid integration:**: Some systems (crafting, wave spawning, core health) are integrated, but UI scoring, saving, and final gameplay loop need more work.


## Accomplishments

### Designed Game Level with Assets

After playing around with the assets, I figured out how to convert them to Universal Render Pipeline. After I figured this, I found starting to design the level was really enjoyable, and adding the assets really brought everything to life. It's not finished, but it's a good start.

![LevelProgress2](https://github.com/xaynia/CART-315/blob/main/Process/Images/FinalProject/Level.gif)

I added a bunch of red mushrooms to add to the inventory to use at the crafting station to visualize them and choose one to use. The dancing mushroom is my favourite.

![LevelProgress2](https://github.com/xaynia/CART-315/blob/main/Process/Images/FinalProject/RedMushrooms.gif)

### Updated Horde (FollowingEnemy.cs) to attack either core or player
Enemies are now set up to target either the player or the core. 

The enemy script (FollowingEnemy.cs) previously only followed the  player. I updated the script to attack the player only or core only. Then I added a new prefab (CoreAttacker), and set it to attack the core (with Enemy.cs in inspector).

This way we can use the same script with two different prefabs, which are both easily added to the spawner (in inspect).

### Updated Core (CoreHealth.cs & added asset)
I added the Enemy.cs logic to make a new script especially for the core's health (CoreHealth.cs). Now the core has a health bar. It needs its own script since it calls the game over scene when it dies.

I replaced the cylinder placeholder with an asset too

![Core](https://github.com/xaynia/CART-315/blob/main/Process/Images/FinalProject/GameOverCore.gif)

## What I Learned
To convert assets when they are hot pink: First, figure out which pipeline you are using. For example, I am using Universal Render Pipeline (URP). So first I make sure the asset is compatible with URP in the asset store. Then once it's imported (and hot pink): select the materials → edit → rendering → convert selected materials to URP. Then when you go to look at the models and prefabs, they will have the right material (instead of grayed out).

![Convert-to-URP](https://github.com/xaynia/CART-315/blob/main/Process/Images/FinalProject/Convert-URP.png)

## Next Steps (Goals)

 - [ ] Add Wave Spawner to Spawner script 
	 - Wave 1, 2, 3...
	 - When last enemy dies → -   If enemies = 0 and get keydown i → then spawn next wave
 
**UI:**
 
 - [ ] Add save system
 - [ ] Add high score
 - [ ] Configure score UI working (so it updates with enemies killed)
 - [ ] Wave counter

**Player:**
 - [ ] Add health (so enemies can damage the player)
	 - [ ] Add first person health bar

**Enemies:**
 - [ ] Add damage player feature (they currently follow the player but do no damage)
 - [ ] Add attack and damage core 

**Continue Working on Level**:
 - [ ] Add Assets:
	 - [ ] Crafting table
	 - [ ] Sounds
	 - [ ] Replace player capsules with character assets

>**Longer-Term Ideas** (If time allows):
>- **Add bomb characters**: Add bomb character ([asset store](https://assetstore.unity.com/packages/3d/characters/3d-monster-bomb-145319)) to the level the player can explode to strategically do more damage
>- **Add sounds**: music, death sound effects, spell sound effects, etc...
>- **Add more crafting objects for different upgrades**: 
>- **Add more unique levels**


## Links:
- [Link to Shared Project](https://github.com/Noe235/CART315FinalProject)
- [Link to Project Media](https://github.com/xaynia/CART-315/tree/main/Process/Images/FinalProject)

# Week 11: Prototype Stage 4

![LevelGhosts](https://github.com/xaynia/CART-315/blob/main/Process/Images/FinalProject/Level.png)

### Last Weeks Accomplished Goals
 - [x] Add Wave Spawner to Spawner script 
 -  [x] Update enviroment assets
	 - [x] Add fire powerups
	 - [x] Added ice powerups
	 - [x] Update enviroment
		 - [x] Fix clouds
		 - [x] Add cuboid animation 
			 - [x]  Fix cuboid (core) from floating away
 - [x] Enemies damage player  
	
**Enemies:**
 - [x] Add damage player feature (they currently follow the player but do no damage)
 - [x] Enemies: kill core

## Idea

### Finish Core loop:
Still working on the core loop, but shifting from implementation to refinement going forward.
### Our Core Loop Accomplishments: 
> Emphasize a specific satisfying core loop of collecting resources, crafting weapons, and defending the core against waves of enemies. 

 **Horde/Wave Defense**
 - [x] Added enemy wave spawner
 - [ ] Add to UI? (e.g.: Score (enemies killed), etc)

**Gathering/Resource Collection**
- [x]  Add assets for player gather during level and upgrade:
	- [x] Flamethrower upgrade: red mushrooms
	- [x] Ice spell: blue mushrooms, ice plants
- [x]   Inventory System

**Resource Gathering → Crafting → Weapon Upgrades:**
- [x] Implemented logic
- [ ] Test 

**Combat**
- [x] Attack:
	- [x] Enemies attack player and core 
	- [x] Player can attack enemies
	- [x] Player can swap spells with keys
- [x] Health: Enemies, player, and core have health and deal damage

### Design Values
**Level Design:**
- Choose aesthetic: 
	- [ ] Minimal design
	- [ ] Add more (add more levels? assets, spells, etc)

## Goals
- Prioritize and plan what we want (to add/remove/update) for the end result
- Test early
	- Stress test
- Refine
- Polish

## Questions to Answer

### Was it a look/feel, role, or implementation prototype?
**Implementation prototype:**
- Implementing the last of the core loop
### Fidelity Levels
**Mid-high fidelity design:** 
- Integrating mechanics
- Learning how to assign assets with animations as a character, and implement existing logic to it
- Lots of debugging while you figure this out

## Accomplishments
### Added Wave Spawner for Enemies
I updated the EnemySpawner.cs script to manage (spawn and track) enemy waves. 

It doesn't start right away, wen you press "I" it spawns the first wave (initially it spawns a wave of 10 enemies). Once the wave is defeated, the player can press "I" key to spawn the next wave which adds 10 more enemies than the previous wave (i.e., wave 2 spawns 20 enemies, wave 3 spawns 30 enemies, and so forth)

- Tracks current wave (`waveIndex`)
- - Boolean checks if a wave is spawning (yes/no) (`waveInProgress`)
- If no wave is spawning and enemiesAlive = 0, press "I" to start a new wave 
- `Spawnwave ( )` spawns wave number + waveIndex with wave count + additional enemies per wave

### Created ghost hordes

- Setup Enemy prefabs as ghost assets
- Made a new script for them
- Tested them
- Added them as prefab variants
	- They kill the player and the core
	- The player can kill them (updated projectile script)

![GhostHorde](https://github.com/xaynia/CART-315/blob/main/Process/Images/FinalProject/GhostHorde.gif)

![GhostHorde](https://github.com/xaynia/CART-315/blob/main/Process/Images/FinalProject/Ghosts.png)

### Added Fire & Ice Area to Level
- Added fire and ice area and a bunch of different mushrooms to choose for to power up weapon

## What I Learned
- Use a sandbox to test assets
- Clear your unity cache

## Question to answers: 
**Wave defense: The player and the core must survive against progressively harder waves. How will this test?**
- Should we add a limited time the player can spawn a new wave (e.g.: 30 seconds) to limit resource gathering?
- Will gathering resources be too easy?
- How will the UI compliment the waves (high score, etc). Would anything else be useful to add?

**How to use Animator for characters:**

**Level Design:**
- Is the level too small? too cluttered with assets?
- Are the resources too easy to get? 
	- Are there too many? Should we have a short respawn window to make resources harder to get?
- Should we add more levels?


## Next Steps (Goals)

### Testing:
Now that the core logic has been implemented, stress testing the core loop ASAP to make sure everything runs smoothly (to debug, make adjustments, etc)
- [ ] **Test core loop:**
	- [ ] Stress test (many) enemy waves 
	- [ ] Test resource gathering & crafting:
		- [ ] Test inventory/gathering scripts
		- [ ] Test inventory/crafting/weapon scripts
	- [ ] Test player first person health bar (if it needs a health script, could use CoreHealth script)

**UI:**
 - [ ] Add save system
 - [ ] Add high score
 - [ ] Configure score UI working (so it updates with enemies killed)
 - [ ] Wave counter

### Level Ideas:
- [ ]  Add Sounds effects
	- [ ] Music
	- [ ] Element sounds (fire, ice)
	- [ ] Player sounds (attack, death)
- [ ] Add crafting table asset for crafting?
- [ ] Add flame/ice assets
 - [ ] Replace player capsules with character assets

>**Longer-Term Ideas** (If time allows):
>- [ ] **Add bomb characters**: Add bomb character ([asset store](https://assetstore.unity.com/packages/3d/characters/3d-monster-bomb-145319)) to the level the player can explode to strategically do more damage
>- [ ] **Add sounds**: music, death sound effects, spell sound effects, etc...
>- [ ]  **Add more crafting objects for different upgrades**: 
>- [ ] **Add another level** (depends on need)

## Links:
- [Link to Project](link)
- [Link to Project Media](https://github.com/xaynia/CART-315/tree/main/Process/Images/FinalProject)

# Week 12 – Final Polish & Build Prep  
*(Iterative Prototype 5 / Release Candidate)*

> **Journal prompt:** What last‑minute changes did we make, why, and how did we wrap everything into a playable build?


## What Changed This Week

### 1 · Sound FX Pass
* Imported spell clip for projectiles
* Hooked them into `AudioManager.I.PlaySFX()` in **FPSShooter**  script.  
  Now every cast *feels* punchy instead of silent nerf‑darts.

### 2 · Game‑Balancing
| Tweak | How we did it | Playtest takeaway |
|-------|---------------|-------------------|
| **Reduced enemy HP** | Serialized field on prefab → tweak → prefab variant override | Allows player now to make past wave 2-3. |
| **10‑second inter‑wave timer** | `EnemySpawner.AutoSpawnNextWave(10f)` | Gives players time to loot/craft/ breathe. |
| **Mushroom cost 10 → 5** | Made this into a refactored variable and set it to 5 | Players can actually reach flamethrower before rage‑quitting. |

### 3 · Message Overlay UI
* Added **HUD (Canvas)** → **MessageText (TMP)**.  
* Tiny singleton `GameMessageUI.Show("text", seconds)` replaces important `Debug.Log`.
    * Wave countdowns  
    * Core under attack alerts  
    * Picked up 1 Item notifications

### 4 · Playability / UX
* Instead of the player having to manually press I to start each round, now the first round kicks off after the global message system counts down. Afterwards the following waves continue to auto spawn once all enemies in the previous wave are defeated.

### 5 · Build & Resolution Fixes
1. **Player Settings → Default Resolution** set to **1600 × 900**.  
2.  Added both scenes (Level & GameOver) to Build Settings.  
3. One test build → spotted mini‑HUD → cranked reference resolution; second build perfect.


## Challenges & Debug Notes

*Unity muted audio again.* Turns out I’d clicked the speaker in Game view.  
Cost: 15 min of “why are my sounds dead?”

*NullReference in `GameMessageUI`* when switching scenes: forgot `DontDestroyOnLoad`.  
Fixed with one line in `Awake()`.


## Reflection

Cutting enemy HP felt scary (“will it be too easy?”), but the playtest proved it: **fun > perfect balance**.  
Adding HUD pop‑ups instantly clarified the flow; players no longer squint at the Console.  
Biggest “aha” was how *resolution settings* can nuke a UI—even a great HUD looks awful at 640×480.  
Lesson: always run a standalone build *before* the deadline.

## Time Log (Toggl) 

* Balancing passes: **4 h 10 m**  
* SFX integration: **1 h 35 m**  
* HUD message system: **2 h 20 m**  
* Build tweaks & testing: **1 h 45 m**  

**Total: 9 h 50 m** this week

---

Thanks for a great semester!
